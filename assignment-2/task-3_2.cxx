/****************************************************************************
Даны неотрицательные целые числа n,k и массив целых чисел из [0..10^9] размера n. Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло на позиции с индексом k (0..n-1) в отсортированном массиве. Напишите нерекурсивный алгоритм.

Требования к дополнительной памяти: O(n). Требуемое среднее время работы: O(n).

Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении. Описание для случая прохода от начала массива к концу:

- Выбирается опорный элемент. Опорный элемент меняется с последним элементом массива.
- Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного. Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат нерассмотренные элементы. Последним элементом лежит опорный.
- Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
- Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
- Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного, то сдвигаем j.
Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
- В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.

           i,j
      а)  ▐ 2 │ 8 │ 7 │ 1 │ 3 │ 5 │ 6 ▐ 4 │
      
               i,j
      б)  ▐ 2 ▐ 8 │ 7 │ 1 │ 3 │ 5 │ 6 ▐ 4 │
      
                i   j
      в)  │ 2 ▐░8░▐ 7 │ 1 │ 3 │ 5 │ 6 ▐ 4 │

                i       j
      г)  │ 2 ▐░8░│░7░▐ 1 │ 3 │ 5 │ 6 ▐ 4 │

                    i       j
      д)  │ 2 │ 1 ▐░7░│░8░▐ 3 │ 5 │ 6 ▐ 4 │

                        i       j
      е)  │ 2 │ 1 │ 3 ▐░8░│░7░▐ 5 │ 6 ▐ 4 │

                        i           j
      ж)  │ 2 │ 1 │ 3 ▐░8░│░7░│░5░▐ 6 ▐ 4 │

                        i               j
      з)  │ 2 │ 1 │ 3 ▐░8░│░7░│░5░│░6░▐ 4 │

                        i
      и)  │ 2 │ 1 │ 3 ▐ 4 ▐░7░│░5░│░6░│░8░▐

****************************************************************************/

/****************************************************************************
Задача 3_2.

Реализуйте стратегию выбора опорного элемента "медиана трёх". Функцию Partition реализуйте методом прохода двумя итераторами от конца массива к началу.
****************************************************************************/

#include <iostream>
#include <algorithm>

using namespace std;

int med(int *a, int b, int n)
{
    int last = a[n-1], middle = a[(b+n-1)/2], first = a[b];
    if(( first >= middle && first <= last ) || ( first <= middle && first >= last ))
    {
        return b;
    }
    else if(( last >= middle && last <= first ) || ( last <= middle && last >= first ))
    {
        return n-1;
    }
    else if(( first <= middle && middle <= last ) || ( first >= middle && middle >= last ))
    {
        return (b+n)/2;
    }
}

int Partition(int *a, int b, int n)
{
    int r = med(a,b,n);
    swap(a[r],a[b]);
    int i=n-1, j=n-1;
    while(j>b)
    {
        if(a[j]<a[b]) j--;
        else
        {
            swap(a[j],a[i]);
            j--;
            i--;
        }
    };
    swap(a[i],a[b]);
    return i;
}

int FindKStatistics( int* arr, int n, int k )
{
    int begin = 0;
    int end = n;
    while( true ) {
        int pivotPos = Partition( arr, begin, end );
        if( pivotPos == k ) {
            return arr[k];
        }
        if( pivotPos < k ) {
            begin = pivotPos + 1;
        } else {
            end = pivotPos;
        }
    }
}

int main()
{
    int n,d;
    bool e = true;
    cin >> n >> d;
    int *arr = new int[n];
    for(int i=0;i<n;i++)
        cin >> arr[i];
    int m = FindKStatistics(arr,n,d);
    cout << m;
    delete []arr;
    return 0;
}
